import * as fs from "fs";
import * as path from "path";
import jsYaml from "js-yaml";
import debug from "debug";
import { getWorkflowsPaths, clearImportCache } from "./utils";
import * as tsNode from "ts-node";

const log = debug("ghawac");

const relativePath = p => path.relative(process.cwd(), p);

const TOP_YAML_WORKFLOW_COMMENT = [
    "# This file was automatically generated by github-actions-wac.",
    "# DO NOT MODIFY IT BY HAND. Instead, modify the source *.wac.ts file(s)",
    '# and run "github-actions-wac build" (or "ghawac build") to regenerate this file.',
    '# For more information, run "github-actions-wac --help".'
].join("\n");

let tsNodeRegistered = false;
const registerTsNode = (options = {}) => {
    if (tsNodeRegistered) {
        return;
    }

    tsNode.register({...options });
    tsNodeRegistered = true;
};

export const build = async () => {

    registerTsNode();

    const workflowFilesPaths = getWorkflowsPaths();
    log(
        "Detected following workflow files:\n",
        workflowFilesPaths.map(item => `-> ${relativePath(item)}`).join("\n")
    );

    for (let i = 0; i < workflowFilesPaths.length; i++) {
        const tsWorkflowPath = workflowFilesPaths[i];
        const exportedWorkflows = await import(tsWorkflowPath);
        for (const name in exportedWorkflows) {
            const yamlWorkflowPath = path.join(path.dirname(tsWorkflowPath), `${name}.yml`);
            log(`Writing to ${relativePath(yamlWorkflowPath)}:`);

            const content = jsYaml.dump(exportedWorkflows[name]);
            log("%s", `\n${content}`);

            fs.writeFileSync(yamlWorkflowPath, [TOP_YAML_WORKFLOW_COMMENT, content].join("\n"));
        }
    }

    // For the "watch" command, we need to flush the cached imported files. Otherwise, once imported, the
    // above dynamic imports will always just returned cached imported objects and no change will happen.
    clearImportCache();

    console.log(`Successfully generated ${workflowFilesPaths.length} file(s).`);
};
